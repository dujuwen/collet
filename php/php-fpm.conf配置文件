http://php.net/manual/zh/install.fpm.configuration.php

; 约定一下,log文件通通写到/var/log/类型(nginx|php|php-fpm|mysql|redis)/级别(access|info|error...).log
; pid文件一律放到/run/类型/类型.pid

; 在php(php-fpm)配置中
; Boolean flags can be turned on using the values 1, On, True or Yes.
; They can be turned off using the values 0, Off, False or No.

如何kill掉php-fpm:
pkill php-fpm

如何平滑重启php-fpm:
kill -s USR2 `cat /run/php-fpm/php-fpm.pid`
kill -USR2 `cat /run/php-fpm/php-fpm.pid`

如何平滑重启nginx:
nginx -s reload
kill -HUP `cat /run/nginx.pid`

-------------------------------------------
/etc/php-fpm.conf
-------------------------------------------

[global]
pid = /run/php-fpm/php-fpm.pid

error_log = /var/log/php-fpm/error.log

log_level = notice

; http://www.04007.cn/article/441.html
; 如果子进程在 emergency_restart_interval 设定的时间内收到该参数设定次数的 SIGSEGV 或者 SIGBUS退出信号，则FPM会重新启动
; SIGBUS(Bus error)意味着指针所对应的地址是有效地址，但总线不能正常使用该指针。通常是未对齐的数据访问所致。
; SIGSEGV(Segment fault)意味着指针所对应的地址是无效地址，没有物理内存对应该地址。
emergency_restart_threshold = 10

; emergency_restart_interval 用于设定平滑重启的间隔时间
; Available Units: s(econds), m(inutes), h(ours), or d(ays)
; Default Unit: seconds
; 5分钟内收到10次异常信号就优雅的重启php-fpm
emergency_restart_interval = 300

; php进程信号复用: php-fpm作为一个调度员，会自动让空闲的FastCGI进程去处理请求，但是在分配请求给php进程前，PHP-FPM需要发送一个进程复用信号给
; FastCGI，以让FastCGI准备请求处理。但是FastCGI进程并不总是能够处理请求，也就是不能够响应进程复用信号，这个参数就表示了PHP-FPM留给FastCGI
; 进程多久时间去响应进程复用信号，如果超时PHP-FPM会选择其他的fastcgi去处理。
process_control_timeout = 10

daemonize = yes ;设置php fpm在后台运行,开放环境调试的时候可以将这个值设置为no

rlimit_files = 65535

;;;;;;;;;;;;;;;;;;;;
; Pool Definitions ;
;;;;;;;;;;;;;;;;;;;;

include /etc/php-fpm.d/*.conf

-------------------------------------------
/etc/php-fpm.d/www.conf 这里www为池名称
-------------------------------------------
[www]

user = nginx
group = nginx

; 接收fastcgi请求的地址
; 也可以配置成socket, /run/php-fpm.sock，对应的nginx配置 fastcgi_pass   unix:/run/php-fpm.sock;
; tcp在高并发的时候具有更好的稳定性
; 这里的listen会影响nginx中的配置: fastcgi_pass   127.0.0.1:9000; 这两处要保持一致
listen = 127.0.0.1:9000

; http://www.hao32.com/webserver/459.html
; No, it means that up to 511 connections can be queued in kernel listen
; queue. 511 is just a safe limit for the most OSes. For FreeBSD it’s -1,
; i.e., value of sysctl kern.ipc.somaxconn.
; May I modify it to 1024 or higher( I am sure use it less than SOMAXCONN )
; 在修改下面的值之前要修改系统内核配置(也可以直接修改配置文件/etc/sysctl.conf):
; sysctl -a | grep somaxconn，sysctl net.core.somaxconn=1024，sysctl -p
listen.backlog = 1024

; Set permissions for unix socket, if one is used.
; 为socket连接设置权限,tcp连接这里不用管
;listen.owner = _www
;listen.group = _www
;listen.mode = 0660

; Makes sense only with a tcp listening socket. Each address
; must be separated by a comma(,). If this value is left blank, connections will be
; accepted from any ip address.
; Default Value: any
; 如果没有其他服务器连接到这台机器上可以设置这个为本地地址
listen.allowed_clients = 127.0.0.1

; process manager配置
pm = dynamic
; pm.max_children可以根据内存动态调整,按照一个30M估算
pm.max_children = 80 ;这里顶峰的时候需要2.4G内存
pm.start_servers = 3
pm.min_spare_servers = 1
pm.max_spare_servers = 3




