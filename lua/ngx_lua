类似json，比json更快且占用空间更加小。如果空间很重要的话可以考虑使用它

https://msgpack.org/
http://fperrad.github.io/lua-MessagePack/

nginx lua文档
https://www.nginx.com/resources/wiki/modules/lua/
https://github.com/openresty/lua-nginx-module

ngx_lua中文翻译
https://github.com/iresty/nginx-lua-module-zh-wiki

1.lua_code_cache
语法: lua_code_cache on | off
默认: lua_code_cache on
环境: http, server, location, location if
打开或者关闭 *_by_lua_file 指令（类似 set_by_lua_file 和 content_by_lua_file） 中指定的 Lua 代码，以及 Lua 模块的 Lua 代码缓存。

在开发环境应该关闭，在生产环境应该打开。如果想要完全读取新的lua代码应该重启Nginx

2.lua_regex_cache_max_entries
语法: lua_regex_cache_max_entries <num>
默认: lua_regex_cache_max_entries 1024
环境: http

正则表达式被用于 ngx.re.match， ngx.re.gmatch， ngx.re.sub， 和 ngx.re.gsub，如果使用o (既，编译一次的标识)正则选项，将会被缓存。
允许的默认数量为 1024，当达到此限制，新的正则表达式将不会被缓存（就像没指定o选项一样），将会有且仅只有一个告警信息在 error.log 文件中
对于部分正则表达式（字符串的各种替换，如 ngx.re.sub 和 ngx.re.gsub），不要使用 o选项，这类正则每次都不一样，缓存无法被利用。
这样我们可以避免撞上最大数的限制。

3.init_by_lua_block
语法: init_by_lua_block { lua-script }
环境: http
阶段: loading-config
与 init_by_lua 指令相似，只不过该指令在一对括号（{}）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。
例如：
通常，你可以在服务启动时注册 Lua 全局变量或预加载 Lua 模块。这是个预加载Lua模块的示例代码：
 init_by_lua {
     cjson = require "cjson"'
  }

 server {
     location = /api {
         content_by_lua_block {
             ngx.say(cjson.encode({dog = 5, cat = 6}))
         }
     }
 }
 
 你也可以在这个阶段初始化lua_shared_dict共享内存内容。这里是示例代码：

 lua_shared_dict dogs 1m;

 init_by_lua {
     local dogs = ngx.shared.dogs
     dogs:set("Tom", 56)
 }

 server {
     location = /api {
         content_by_lua_block {
             local dogs = ngx.shared.dogs
             ngx.say(dogs:get("Tom"))
         }
     }
 }
 
 在这个上下文中，只有一小部分的 Nginx Lua API 是被支持的：
记录日志的 APIs：ngx.log 和 print
共享内存字典 APIs：ngx.shared.DICT

4.content_by_lua_block
语法: content_by_lua_block { lua-script }
环境: location, location if
阶段: content

与 content_by_lua 指令相似，只不过该指令在一对括号（{}）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。

例如：
 content_by_lua_block {
     ngx.say("I need no extra escaping here, for example: \r\nblah")
 }

作为"内容处理程序"，为每一个请求执行<lua-script-str>中指定的Lua代码。
这些 Lua 代码可以调用 全部 API，并作为一个新的协程，在一个独立的全局环境中执行（就像一个沙盒）。
不要将本指令和其他内容处理程序指令放到同一个 location 中。 比如，本指令和 proxy_pass 指令就不能在同一个 location 中使用。

5.lua_shared_dict
语法: lua_shared_dict <name> <size>
默认: no
环境: http
阶段: depends on usage

声明一个共享内存区块 <name>，用来存储基于共享内存的 Lua 字典 ngx.shared.<name>。
在当前 Nginx 服务器实例中，共享内存区块被所有 nginx worker 进程共享。

<size> 参数可以通过类似 k 和 m 的大小单位来设置。

 http {
     lua_shared_dict dogs 10m;
     ...
 }
硬编码限制最小大小是 8KB，而实际的最小大小取决于实际中用户数据集（有些人是从 12KB 开始）。
更多细节请参考 ngx.shared.DICT。

6.lua_transform_underscores_in_response_headers
语法: lua_transform_underscores_in_response_headers on|off
默认: lua_transform_underscores_in_response_headers on
环境: http, server, location, location-if
对于 ngx.header.HEADER API 中指定响应头，该指令指定是否将下划线(_)转化为连接线(-)。

7.
