类似json，比json更快且占用空间更加小。如果空间很重要的话可以考虑使用它

https://msgpack.org/
http://fperrad.github.io/lua-MessagePack/

nginx lua文档
https://www.nginx.com/resources/wiki/modules/lua/
https://github.com/openresty/lua-nginx-module

ngx_lua中文翻译
https://github.com/iresty/nginx-lua-module-zh-wiki

1.lua_code_cache
语法: lua_code_cache on | off
默认: lua_code_cache on
环境: http, server, location, location if
打开或者关闭 *_by_lua_file 指令（类似 set_by_lua_file 和 content_by_lua_file） 中指定的 Lua 代码，以及 Lua 模块的 Lua 代码缓存。

在开发环境应该关闭，在生产环境应该打开。如果想要完全读取新的lua代码应该重启Nginx

2.lua_regex_cache_max_entries
语法: lua_regex_cache_max_entries <num>
默认: lua_regex_cache_max_entries 1024
环境: http

正则表达式被用于 ngx.re.match， ngx.re.gmatch， ngx.re.sub， 和 ngx.re.gsub，如果使用o (既，编译一次的标识)正则选项，将会被缓存。
允许的默认数量为 1024，当达到此限制，新的正则表达式将不会被缓存（就像没指定o选项一样），将会有且仅只有一个告警信息在 error.log 文件中
对于部分正则表达式（字符串的各种替换，如 ngx.re.sub 和 ngx.re.gsub），不要使用 o选项，这类正则每次都不一样，缓存无法被利用。
这样我们可以避免撞上最大数的限制。

3.init_by_lua_block
语法: init_by_lua_block { lua-script }
环境: http
阶段: loading-config
与 init_by_lua 指令相似，只不过该指令在一对括号（{}）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。
例如：
通常，你可以在服务启动时注册 Lua 全局变量或预加载 Lua 模块。这是个预加载Lua模块的示例代码：
 init_by_lua {
     cjson = require "cjson"'
  }

 server {
     location = /api {
         content_by_lua_block {
             ngx.say(cjson.encode({dog = 5, cat = 6}))
         }
     }
 }
 
 你也可以在这个阶段初始化lua_shared_dict共享内存内容。这里是示例代码：

 lua_shared_dict dogs 1m;

 init_by_lua {
     local dogs = ngx.shared.dogs
     dogs:set("Tom", 56)
 }

 server {
     location = /api {
         content_by_lua_block {
             local dogs = ngx.shared.dogs
             ngx.say(dogs:get("Tom"))
         }
     }
 }
 
 在这个上下文中，只有一小部分的 Nginx Lua API 是被支持的：
记录日志的 APIs：ngx.log 和 print
共享内存字典 APIs：ngx.shared.DICT

4.content_by_lua_block
语法: content_by_lua_block { lua-script }
环境: location, location if
阶段: content

与 content_by_lua 指令相似，只不过该指令在一对括号（{}）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。

例如：
 content_by_lua_block {
     ngx.say("I need no extra escaping here, for example: \r\nblah")
 }

作为"内容处理程序"，为每一个请求执行<lua-script-str>中指定的Lua代码。
这些 Lua 代码可以调用 全部 API，并作为一个新的协程，在一个独立的全局环境中执行（就像一个沙盒）。
不要将本指令和其他内容处理程序指令放到同一个 location 中。 比如，本指令和 proxy_pass 指令就不能在同一个 location 中使用。

5.lua_shared_dict
语法: lua_shared_dict <name> <size>
默认: no
环境: http
阶段: depends on usage

声明一个共享内存区块 <name>，用来存储基于共享内存的 Lua 字典 ngx.shared.<name>。
在当前 Nginx 服务器实例中，共享内存区块被所有 nginx worker 进程共享。

<size> 参数可以通过类似 k 和 m 的大小单位来设置。

 http {
     lua_shared_dict dogs 10m;
     ...
 }
硬编码限制最小大小是 8KB，而实际的最小大小取决于实际中用户数据集（有些人是从 12KB 开始）。
更多细节请参考 ngx.shared.DICT。

6.lua_transform_underscores_in_response_headers
语法: lua_transform_underscores_in_response_headers on|off
默认: lua_transform_underscores_in_response_headers on
环境: http, server, location, location-if
对于 ngx.header.HEADER API 中指定响应头，该指令指定是否将下划线(_)转化为连接线(-)。

7.nginx lua api只能在*_by_lua*指令中通过lua代码调用
https://github.com/iresty/nginx-lua-module-zh-wiki#Introduction

Lua 中使用的 API 以两个标准模块的形式封装：ngx 和 ndk。这两个模块在 ngx_lua 默认的全局作用域中，在 ngx_lua 指令中总是可用。

这两个模块可以被用在外部 Lua 模块中，例如：
 local say = ngx.say
 local _M = {}
 function _M.foo(a)
     say(a)
 end
 return _M

在外部 Lua 模块中也可以直接 require 这两个模块：
 local ngx = require "ngx"
 local ndk = require "ndk"
 
 用户代码中的网络 I/O 操作应该使用这些 Nginx Lua API 实现，否则 Nginx 的事件循环可能被阻塞，从而严重影响性能。
 相对小数据量的磁盘操作可以通过标准的 Lua io 库来实现，但大规模的文件读写如果可能应该避免，因为可能会严重阻塞 Nginx 进程。
 为获得最好性能，强烈建议将所有网络和磁盘 I/O 操作发送到 Nginx 的子请求中 (通过类似 ngx.location.capture 的方法) 处理。
 
 8.ngx.var.VARIABLE
语法: ngx.var.VAR_NAME
环境: set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*

读写 Nginx 变量值:
 value = ngx.var.some_nginx_variable_name
 ngx.var.some_nginx_variable_name = value
请注意，只有已经定义的 nginx 变量可以被写入。例如:
 location /foo {
     set $my_var ''; # 需要在设置时创建 $my_var 变量
     content_by_lua_block {
         ngx.var.my_var = 123;
         ...
     }
 }
 
9.Core constants
环境: init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*,
body_filter_by_lua*, *log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*
    ngx.OK (0)
    ngx.ERROR (-1)
    ngx.AGAIN (-2)
    ngx.DONE (-4)
    ngx.DECLINED (-5)
请注意，这些常量中只有三个可以被 Nginx API for Lua 使用 (即 ngx.exit 只接受 NGX_OK, NGX_ERROR, 和 NGX_DECLINED 作为输入)。

ngx.null
ngx.null 常量是一个 NULL 的 轻量用户数据 ，一般被用来表达 Lua table 等里面的 nil (空) 值，类似于 lua-cjson 库中的 cjson.null 常量。

10.HTTP method constants
  ngx.HTTP_GET
  ngx.HTTP_HEAD
  ngx.HTTP_PUT
  ngx.HTTP_POST
  ngx.HTTP_DELETE
  ngx.HTTP_OPTIONS   (v0.5.0rc24 版本加入)
  ngx.HTTP_MKCOL     (v0.8.2 版本加入)
  ngx.HTTP_COPY      (v0.8.2 版本加入)
  ngx.HTTP_MOVE      (v0.8.2 版本加入)
  ngx.HTTP_PROPFIND  (v0.8.2 版本加入)
  ngx.HTTP_PROPPATCH (v0.8.2 版本加入)
  ngx.HTTP_LOCK      (v0.8.2 版本加入)
  ngx.HTTP_UNLOCK    (v0.8.2 版本加入)
  ngx.HTTP_PATCH     (v0.8.2 版本加入)
  ngx.HTTP_TRACE     (v0.8.2 版本加入)
这些常量一般被用在 ngx.location.capture 和 ngx.location.capture_multi 方法中。

11.HTTP status constants
value = ngx.HTTP_CONTINUE (100) (first added in the v0.9.20 release)
   value = ngx.HTTP_SWITCHING_PROTOCOLS (101) (first added in the v0.9.20 release)
   value = ngx.HTTP_OK (200)
   value = ngx.HTTP_CREATED (201)
   value = ngx.HTTP_ACCEPTED (202) (first added in the v0.9.20 release)
   value = ngx.HTTP_NO_CONTENT (204) (first added in the v0.9.20 release)
   value = ngx.HTTP_PARTIAL_CONTENT (206) (first added in the v0.9.20 release)
   value = ngx.HTTP_SPECIAL_RESPONSE (300)
   value = ngx.HTTP_MOVED_PERMANENTLY (301)
   value = ngx.HTTP_MOVED_TEMPORARILY (302)
   value = ngx.HTTP_SEE_OTHER (303)
   value = ngx.HTTP_NOT_MODIFIED (304)
   value = ngx.HTTP_TEMPORARY_REDIRECT (307) (first added in the v0.9.20 release)
   value = ngx.HTTP_BAD_REQUEST (400)
   value = ngx.HTTP_UNAUTHORIZED (401)
   value = ngx.HTTP_PAYMENT_REQUIRED (402) (first added in the v0.9.20 release)
   value = ngx.HTTP_FORBIDDEN (403)
   value = ngx.HTTP_NOT_FOUND (404)
   value = ngx.HTTP_NOT_ALLOWED (405)
   value = ngx.HTTP_NOT_ACCEPTABLE (406) (first added in the v0.9.20 release)
   value = ngx.HTTP_REQUEST_TIMEOUT (408) (first added in the v0.9.20 release)
   value = ngx.HTTP_CONFLICT (409) (first added in the v0.9.20 release)
   value = ngx.HTTP_GONE (410)
   value = ngx.HTTP_UPGRADE_REQUIRED (426) (first added in the v0.9.20 release)
   value = ngx.HTTP_TOO_MANY_REQUESTS (429) (first added in the v0.9.20 release)
   value = ngx.HTTP_CLOSE (444) (first added in the v0.9.20 release)
   value = ngx.HTTP_ILLEGAL (451) (first added in the v0.9.20 release)
   value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)
   value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)
   value = ngx.HTTP_BAD_GATEWAY (502) (first added in the v0.9.20 release)
   value = ngx.HTTP_SERVICE_UNAVAILABLE (503)
   value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release)
   value = ngx.HTTP_VERSION_NOT_SUPPORTED (505) (first added in the v0.9.20 release)
   value = ngx.HTTP_INSUFFICIENT_STORAGE (507) (first added in the v0.9.20 release)

12.Nginx log level constants
ngx.STDERR
   ngx.EMERG
   ngx.ALERT
   ngx.CRIT
   ngx.ERR
   ngx.WARN
   ngx.NOTICE
   ngx.INFO
   ngx.DEBUG
这些常量一般用于 ngx.log 方法.

13.print
语法: print(...)
将参数值以 ngx.NOTICE 日志级别写入 nginx 的 error.log 文件
等同于
ngx.log(ngx.NOTICE, ...)
Lua 的 nil 值输出 "nil" 字符串，Lua 的布尔值输出 "true" 或 "false" 字符串。ngx.null 常量输出为 "null" 字符串。
在 Nginx 内核中硬编码限制了单条错误信息最长为 2048 字节。

14.

