http://www.lua.org/manual/5.1/
https://www.codingnow.com/2000/download/lua_manual.html
http://wiki.jikexueyuan.com/project/openresty/lua/class.html

1.布尔类型，可选值 true/false；Lua 中 nil 和 false 为“假”，其它所有值均为“真”。
比如 0 和空字符串就是“真”

2.table (表)，类似json，获取结果的时候像php中的数组
Table 类型实现了一种抽象的“关联数组”。“关联数组”是一种具有特殊索引方式的数组，索引通常是字符串（string）或者 number 类型，
但也可以是除 nil 以外的任意类型的值。

local corp = {
    web = "www.google.com",   --索引为字符串，key = "web",
                              --            value = "www.google.com"
    telephone = "12345678",   --索引为字符串
    staff = {"Jack", "Scott", "Gary"}, --索引为字符串，值也是一个表
    100876,              --相当于 [1] = 100876，此时索引为数字
                         --      key = 1, value = 100876
    100191,              --相当于 [2] = 100191，此时索引为数字
    [10] = 360,          --直接把数字索引给出
    ["city"] = "Beijing" --索引为字符串
}

print(corp.web)               -->output:www.google.com
print(corp["telephone"])      -->output:12345678
print(corp[2])                -->output:100191
print(corp["city"])           -->output:"Beijing"
print(corp.staff[1])          -->output:Jack
print(corp[10])               -->output:360

3.函数，函数必须以end结尾
local function foo()
    print("in the function")
    --dosomething()
    local x = 10
    local y = 20
    return x + y
end

local a = foo    --把函数赋给变量

print(a())

function foo()
end
等价于
foo = function ()
end

local function foo()
end
等价于
local foo = function ()
end

4.表达式
<=	小于等于
>=	大于等于
==	等于
~=	不等于
print(1 < 2)    -->打印 true
print(1 == 2)   -->打印 false
print(1 ~= 2)   -->打印 true
local a, b = true, false
print(a == b)  -->打印 false

在使用“==”做等于判断时，要注意对于 table, userdate 和函数， Lua 是作引用比较的。也就是说，只有当两个变量引用同一个对象时，才认为它们相等。
local a = { x = 1, y = 0}
local b = { x = 1, y = 0}
if a == b then
  print("a==b")
else
  print("a~=b") --输出不等
end

由于 Lua 字符串总是会被“内化”，即相同内容的字符串只会被保存一份，因此 Lua 字符串之间的相等性比较可以简化为其内部存储地址的比较。
这意味着 Lua 字符串的相等性比较总是为 O(1). 而在其他编程语言中，字符串的相等性比较则通常为 O(n)，即需要逐个字节（或按若干个连续字节）进行比较。

5.逻辑运算符
and	逻辑与
or	逻辑或
not	逻辑非

在 c 语言中，and 和 or 只得到两个值 1 和 0，其中 1 表示真，0 表示假。Lua 中 and 的执行过程是这样的：
a and b 如果 a 为 nil，则返回 a，否则返回 b;
a or b 如果 a 为 nil，则返回 b，否则返回 a。
and找第一个假 or找第一个真
local c = nil
local d = 0
local e = 100
print(c and d)  -->打印 nil
print(c and e)  -->打印 nil
print(d and e)  -->打印 100
print(c or d)   -->打印 0
print(c or e)   -->打印 100
print(not c)    -->打印 true
print(not d)    -->打印 false

6.字符串连接
在 Lua 中连接两个字符串，可以使用操作符“..”（两个点）。如果其任意一个操作数是数字的话，Lua 会将这个数字转换成字符串。
注意，连接操作符只会创建一个新字符串，而不会改变原操作数。也可以使用 string 库函数 string.format 连接字符串。
print("Hello " .. "World")    -->打印 Hello World
print(0 .. 1)                 -->打印 01

str1 = string.format("%s-%s","hello","world")
print(str1)              -->打印 hello-world

str2 = string.format("%d-%s-%.2f",123,"world",1.21)
print(str2)              -->打印 123-world-1.21

由于 Lua 字符串本质上是只读的，因此字符串连接运算符几乎总会创建一个新的（更大的）字符串。这意味着如果有很多这样的连接操作
（比如在循环中使用 .. 来拼接最终结果），则性能损耗会非常大。在这种情况下，推荐使用 table 和 table.concat() 来进行很多字符串的拼接，例如：
local pieces = {}
for i, elem in ipairs(my_list) do
    pieces[i] = my_process(elem)
end
local res = table.concat(pieces)

7.if/else
score = 90
if score == 100 then
    print("Very good!Your score is 100")
elseif score >= 60 then
    print("Congratulations, you have passed it,your score greater or equal to 60")
--此处可以添加多个elseif
else
    print("Sorry, you do not pass the exam! ")
end


8.while
while 表达式 do
--body
end

x = 1
sum = 0

while x <= 5 do
    sum = sum + x
    x = x + 1
end
print(sum)  -->output 15

值得一提的是，Lua 并没有像许多其他语言那样提供类似 continue 这样的控制语句用来立即进入下一个循环迭代（如果有的话）。
因此，我们需要仔细地安排循环体里的分支，以避免这样的需求。

没有提供 continue，却也提供了另外一个标准控制语句 break，可以跳出当前循环。例如我们遍历 table，查找值为 11 的数组下标索引：
local t = {1, 3, 5, 8, 11, 18, 21}

local i
for i, v in ipairs(t) do
    if 11 == v then
        print("index[" .. i .. "] have right value[11]")
        break
    end
end

9.for
http://wiki.jikexueyuan.com/project/openresty/lua/for.html

for 语句有两种形式：数字 for（numeric for）和范型 for（generic for）

for var = begin, finish, step do
    --body
end

for i = 1, 5 do
  print(i)
end

-- 打印数组a的所有值
local a = {"a", "b", "c", "d"}
for i, v in ipairs(a) do
  print("index:", i, " value:", v)
end

-- 打印table t中所有的key
for k in pairs(t) do
    print(k)
end

标准库提供了几种迭代器，包括用于迭代文件中每行的（io.lines）、 迭代 table 元素的（pairs）、迭代数组元素的（ipairs）、
迭代字符串中单词的（string.gmatch）等

值得一提的是，在 LuaJIT 2.1 中，ipairs() 内建函数是可以被 JIT 编译的，而 pairs() 则只能被解释执行。因此在性能敏感的场景，
应当合理安排数据结构，避免对哈希表进行遍历。

10.break和return
http://wiki.jikexueyuan.com/project/openresty/lua/break.html

语句 break 用来终止 while、repeat 和 for 三种循环的执行，并跳出当前循环体， 继续执行当前循环之后的语句
return 主要用于从函数中返回结果，或者用于简单的结束一个函数的执行

11.函数
function function_name (arc)  -- arc 表示参数列表，函数的参数列表可以为空
   -- body
end

由于全局变量一般会污染全局名字空间，同时也有性能损耗（即查询全局环境表的开销），因此我们应当尽量使用“局部函数”，
其记法是类似的，只是开头加上 local 修饰符
local function function_name (arc)
  -- body
end

foo.bar = function (a, b, c)
    print(a, b, c)
end
此时我们是把一个函数类型的值赋给了 foo 表的 bar 字段,对于此种形式的函数定义，不能再使用 local 修饰符了，因为不存在定义新的局部变量了

12.

