http://www.lua.org/manual/5.1/
https://www.codingnow.com/2000/download/lua_manual.html
http://wiki.jikexueyuan.com/project/openresty/lua/class.html

1.布尔类型，可选值 true/false；Lua 中 nil 和 false 为“假”，其它所有值均为“真”。
比如 0 和空字符串就是“真”

2.table (表)，类似json，获取结果的时候像php中的数组
Table 类型实现了一种抽象的“关联数组”。“关联数组”是一种具有特殊索引方式的数组，索引通常是字符串（string）或者 number 类型，
但也可以是除 nil 以外的任意类型的值。

local corp = {
    web = "www.google.com",   --索引为字符串，key = "web",
                              --            value = "www.google.com"
    telephone = "12345678",   --索引为字符串
    staff = {"Jack", "Scott", "Gary"}, --索引为字符串，值也是一个表
    100876,              --相当于 [1] = 100876，此时索引为数字
                         --      key = 1, value = 100876
    100191,              --相当于 [2] = 100191，此时索引为数字
    [10] = 360,          --直接把数字索引给出
    ["city"] = "Beijing" --索引为字符串
}

print(corp.web)               -->output:www.google.com
print(corp["telephone"])      -->output:12345678
print(corp[2])                -->output:100191
print(corp["city"])           -->output:"Beijing"
print(corp.staff[1])          -->output:Jack
print(corp[10])               -->output:360

3.函数，函数必须以end结尾
local function foo()
    print("in the function")
    --dosomething()
    local x = 10
    local y = 20
    return x + y
end

local a = foo    --把函数赋给变量

print(a())

function foo()
end
等价于
foo = function ()
end

local function foo()
end
等价于
local foo = function ()
end

4.表达式
<=	小于等于
>=	大于等于
==	等于
~=	不等于
print(1 < 2)    -->打印 true
print(1 == 2)   -->打印 false
print(1 ~= 2)   -->打印 true
local a, b = true, false
print(a == b)  -->打印 false

在使用“==”做等于判断时，要注意对于 table, userdate 和函数， Lua 是作引用比较的。也就是说，只有当两个变量引用同一个对象时，才认为它们相等。
local a = { x = 1, y = 0}
local b = { x = 1, y = 0}
if a == b then
  print("a==b")
else
  print("a~=b") --输出不等
end

由于 Lua 字符串总是会被“内化”，即相同内容的字符串只会被保存一份，因此 Lua 字符串之间的相等性比较可以简化为其内部存储地址的比较。
这意味着 Lua 字符串的相等性比较总是为 O(1). 而在其他编程语言中，字符串的相等性比较则通常为 O(n)，即需要逐个字节（或按若干个连续字节）进行比较。

5.逻辑运算符
and	逻辑与
or	逻辑或
not	逻辑非

在 c 语言中，and 和 or 只得到两个值 1 和 0，其中 1 表示真，0 表示假。Lua 中 and 的执行过程是这样的：
a and b 如果 a 为 nil，则返回 a，否则返回 b;
a or b 如果 a 为 nil，则返回 b，否则返回 a。
and找第一个假 or找第一个真
local c = nil
local d = 0
local e = 100
print(c and d)  -->打印 nil
print(c and e)  -->打印 nil
print(d and e)  -->打印 100
print(c or d)   -->打印 0
print(c or e)   -->打印 100
print(not c)    -->打印 true
print(not d)    -->打印 false

6.字符串连接
在 Lua 中连接两个字符串，可以使用操作符“..”（两个点）。如果其任意一个操作数是数字的话，Lua 会将这个数字转换成字符串。
注意，连接操作符只会创建一个新字符串，而不会改变原操作数。也可以使用 string 库函数 string.format 连接字符串。
print("Hello " .. "World")    -->打印 Hello World
print(0 .. 1)                 -->打印 01

str1 = string.format("%s-%s","hello","world")
print(str1)              -->打印 hello-world

str2 = string.format("%d-%s-%.2f",123,"world",1.21)
print(str2)              -->打印 123-world-1.21

由于 Lua 字符串本质上是只读的，因此字符串连接运算符几乎总会创建一个新的（更大的）字符串。这意味着如果有很多这样的连接操作
（比如在循环中使用 .. 来拼接最终结果），则性能损耗会非常大。在这种情况下，推荐使用 table 和 table.concat() 来进行很多字符串的拼接，例如：
local pieces = {}
for i, elem in ipairs(my_list) do
    pieces[i] = my_process(elem)
end
local res = table.concat(pieces)

7.if/else
score = 90
if score == 100 then
    print("Very good!Your score is 100")
elseif score >= 60 then
    print("Congratulations, you have passed it,your score greater or equal to 60")
--此处可以添加多个elseif
else
    print("Sorry, you do not pass the exam! ")
end


8.while
while 表达式 do
--body
end

x = 1
sum = 0

while x <= 5 do
    sum = sum + x
    x = x + 1
end
print(sum)  -->output 15

值得一提的是，Lua 并没有像许多其他语言那样提供类似 continue 这样的控制语句用来立即进入下一个循环迭代（如果有的话）。
因此，我们需要仔细地安排循环体里的分支，以避免这样的需求。

没有提供 continue，却也提供了另外一个标准控制语句 break，可以跳出当前循环。例如我们遍历 table，查找值为 11 的数组下标索引：
local t = {1, 3, 5, 8, 11, 18, 21}

local i
for i, v in ipairs(t) do
    if 11 == v then
        print("index[" .. i .. "] have right value[11]")
        break
    end
end

9.for
http://wiki.jikexueyuan.com/project/openresty/lua/for.html

for 语句有两种形式：数字 for（numeric for）和范型 for（generic for）

for var = begin, finish, step do
    --body
end

for i = 1, 5 do
  print(i)
end

-- 打印数组a的所有值
local a = {"a", "b", "c", "d"}
for i, v in ipairs(a) do
  print("index:", i, " value:", v)
end

-- 打印table t中所有的key
for k in pairs(t) do
    print(k)
end

标准库提供了几种迭代器，包括用于迭代文件中每行的（io.lines）、 迭代 table 元素的（pairs）、迭代数组元素的（ipairs）、
迭代字符串中单词的（string.gmatch）等

值得一提的是，在 LuaJIT 2.1 中，ipairs() 内建函数是可以被 JIT 编译的，而 pairs() 则只能被解释执行。因此在性能敏感的场景，
应当合理安排数据结构，避免对哈希表进行遍历。

10.break和return
http://wiki.jikexueyuan.com/project/openresty/lua/break.html

语句 break 用来终止 while、repeat 和 for 三种循环的执行，并跳出当前循环体， 继续执行当前循环之后的语句
return 主要用于从函数中返回结果，或者用于简单的结束一个函数的执行

11.函数
function function_name (arc)  -- arc 表示参数列表，函数的参数列表可以为空
   -- body
end

由于全局变量一般会污染全局名字空间，同时也有性能损耗（即查询全局环境表的开销），因此我们应当尽量使用“局部函数”，
其记法是类似的，只是开头加上 local 修饰符
local function function_name (arc)
  -- body
end

foo.bar = function (a, b, c)
    print(a, b, c)
end
此时我们是把一个函数类型的值赋给了 foo 表的 bar 字段,对于此种形式的函数定义，不能再使用 local 修饰符了，因为不存在定义新的局部变量了

12.可变参数
local function func( ... )                -- 形参为 ... ,表示函数采用变长参数

   local temp = {...}                     -- 访问的时候也要使用 ...
   local ans = table.concat(temp, " ")    -- 使用 table.concat 库函数对数
                                          -- 组内容使用 " " 拼接成字符串。
   print(ans)
end

按引用传递
当函数参数是 table 类型时，传递进来的是 实际参数的引用，此时在函数内部对该 table 所做的修改，会直接对调用者所传递的实际参数生效，
而无需自己返回结果和让调用者进行赋值。

在常用基本类型中，除了 table 是按址传递类型外，其它的都是按值传递参数。 用全局变量来代替函数参数的不好编程习惯应该被抵制，
良好的编程习惯应该是减少全局变量的使用。

13.lua中函数可以有多个返回值
local s, e = string.find("hello world", "llo")
print(s, e)  -->output 3  5

local function swap(a, b)   -- 定义函数 swap，实现两个变量交换值
   return b, a              -- 按相反顺序返回变量的值
end

如果你确保只取函数返回值的第一个值，可以使用括号运算符，例如

local function init()
    return 1, "lua"
end

print((init()), 2)   -->output  1  2
print(2, (init()))   -->output  2  1

14.模块
my.lua:
local foo={}

local function getname()
    return "Lucy"
end

function foo.greeting()
    print("hello " .. getname())
end

foo.hello = function ()
	print("djw " .. getname())
end

return foo

另外一个文件调用
local t = require("my")
t.hello()

可以使用内建函数 require() 来加载和缓存模块。简单的说，一个代码模块就是一个程序库，可以通过 require 来加载。模块加载后的结果通过是一个 Lua table，
这个表就像是一个命名空间，其内容就是模块中导出的所有东西，比如函数和变量。

15.字符串
Lua 中有三种方式表示字符串:
1)、使用一对匹配的单引号。例：'hello'。
2)、使用一对匹配的双引号。例："abclua"。
3)、字符串还可以用一种长括号（即[[ ]]）括起来的方式定义
把两个正的方括号（即[[）间插入 n 个等号定义为第 n 级正长括号。就是说，0 级正的长括号写作 [[ ，一级正的长括号写作 [=[，如此等等
例：[[abc\nbc]]，里面的 "\n" 不会被转义。

16.需要特别注意的一点是，Lua 字符串内部用来标识各个组成字节的下标是从 1 开始的，表的下标也是从1开始的这一点跟php不一样

17.string库
string.upper(str) --将字符串中的英文字母全部转换成大写
string.sub(str, 3, 7) --直接表示从第三个字符开始到第七个字符（含）为止的子串
string.byte(s [, i [, j ]]) --返回字符 s[i]、s[i + 1]、s[i + 2]、······、s[j] 所对应的 ASCII 码。i 的默认值为 1，即第一个字节,j 的默认值为 i 。
string.char (...) --接收 0 个或更多的整数（整数范围：0~255），返回这些整数所对应的 ASCII 码字符组成的字符串。当参数为空时，默认是一个 0。
string.lower(s) --接收一个字符串 s，返回一个把所有大写字母变成小写字母的字符串。
string.len(s) --接收一个字符串，返回它的长度。一个汉字占4个字节长度。使用此函数是不推荐的。应当总是使用 # 运算符来获取 Lua 字符串的长度。
string.find(s, p [, init [, plain]])
-- 在 s 字符串中第一次匹配 p 字符串。若匹配成功，则返回 p 字符串在 s 字符串中出现的开始位置和结束位置；若匹配失败，则返回 nil。 
第三个参数 init 默认为 1，并且可以为负整数，当 init 为负数时，表示从 s 字符串的 string.len(s) + init 索引处开始向后匹配字符串 p 。
第四个参数默认为 false，当其为 true 时，只会把 p 看成一个字符串对待。

例如:
print(string.char(65,66)) -- AB

local name = 'duJUNweN哈'
-- 由于 Lua 字符串的长度是专门存放的，并不需要像 C 字符串那样即时计算，因此获取字符串长度的操作总是 O(1) 的时间复杂度。
print(#name) -- 11


